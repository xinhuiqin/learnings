《排序算法3：插入排序(insertion sort)》
---------------------------------------------------------

# 定义

给要插入的元素腾出空间，将其余元素在插入之前都后移一位，从而得到有序序列的算法称为插入排序。对于这个算法，要把握住“后移一位”这个操作。

# 原理

1、起点：将元素插入到已排序序列中，那么这个已排序序列在哪里？显然无元素或者只有一个元素的序列能满足要求。所以遍历的时候可以直接从索引为1的元素开始。只需要遍历n-1次。

2、后移：怎么知道这个元素应该插入到已排序序列的哪个位置呢？那么从该元素的索引开始，逐个向前扫描，如果已排序序列的元素大于该元素，则已排序的元素后移一位，直到已排序的元素比该元素小。

3、当前记录处理：插入排序需要用一个变量处理当前记录，以表示索引的移动。

# 算法分析

1、时间复杂度

外层循环至少n-1次，内层循环最坏情况：n-1次，所以时间复杂度为O(n^2^)。

2、空间复杂度

只有临时变量需要开辟额外的存储空间，所以空间复杂度为O(1)。

# 参考资料

[1] Robert Sedgewick, Kevin Wayne. 算法(第4版)[M]. 北京: 人民邮电出版社, 2016.

[2] 裘宗燕. 数据结构与算法[M]. 北京:  机械工业出版社, 2017.

[3] 裘宗燕, http://www.math.pku.edu.cn/teachers/qiuzy/ds_python/courseware/index.htm

# 代码实现

```
class Solution:
    def insertion_sort(self, lst):
        n = len(lst)
        # 第一个元素默认是有序的，因为是逐个取下一个元素，所以需要到n
        for i in range(1, n): 
            # 要插入的元素
            tmp = lst[i]
            j = i
            # 一直比较到第0个元素，所以循环的条件是j > 0
            while j > 0 and lst[j-1] > tmp:
                # 前一个元素后移一个位置
                lst[j] = lst[j-1]
                j -= 1
            # j即是要插入的位置，将数据插入到该位置
            lst[j] = tmp
        return lst




if __name__ == '__main__':
    example = [49, 38, 65, 97, 76, 13, 27, 49, 55, 4]
    s = Solution()
    res = s.insertion_sort(example)
    print(res)  # [4, 13, 27, 38, 49, 49, 55, 65, 76, 97]

```

